# 案例

```JavaScript
0.1+0.2 === 0.3    //false
```

> 实际情况是：

```JavaScript
let n1 = 0.1, n2 = 0.2
console.log(n1 + n2)  // 0.30000000000000004

```

为什么会出现这样的问题呢？

# 概述

计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是`0.0001100110011001100...`（1100循环），0.2的二进制是：`0.00110011001100...`（1100循环），这两个数的二进制都是无限循环的数。



而JavaScript对于数字类型，遵循`IEEE754标准`，使用`64位`固定长度来表示，也就是标准的**double双精度浮点数**。在二进制科学表示法中，双精度浮点数的小数部分最多只能保存52位，再加上前面的1位（符号位），其实就是保存53位有效数组，剩余的需要舍去，遵从“0舍1入”的原则。







---

# 如何实现0.1+0.2=0.3？

## 1.使用JavaScript提供的最小精度值判断误差是否在该值范围内

ES6中的Number.EPSILON属性。

```JavaScript
function numberepsilon(arg1,arg2){                   
  return Math.abs(arg1 - arg2) < Number.EPSILON;        
}        

console.log(numberepsilon(0.1 + 0.2, 0.3)); // true

```



## 2.转为整数计算，计算后再转回小数

## 3.使用轮子，例如：math.js

## 4.转成字符串相加

